#include <GLFW/glfw3.h>

#include <irrlicht.h>
#include <nanogui/nanogui.h>

#include <iostream>

using namespace irr;
using namespace nanogui;

Screen *screen = nullptr;

i32 winWidth = 1280;
i32 winHeight = 720;

i32 main(i32 argc, char **argv) {
    glfwInit();

    glfwSetTime(0);

    // Create a GLFWwindow object
    GLFWwindow* window = glfwCreateWindow(winWidth, winHeight, "example3", nullptr, nullptr);
    if (window == nullptr) {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);

    // Irrlicht
    SIrrlichtCreationParameters param;
    param.DeviceType = E_DEVICE_TYPE::EIDT_GLFW3;
    param.DriverType = video::E_DRIVER_TYPE::EDT_OPENGL;
    param.WindowId = window;
    param.IgnoreInput = true;
    param.WindowSize = core::dimension2du(winWidth, winHeight);
    IrrlichtDevice* device = createDeviceEx(param);
    if (!device) return 1;

    video::IVideoDriver* driver = device -> getVideoDriver();
    driver -> setTextureCreationFlag(video::ETCF_ALWAYS_32_BIT, true);

    scene::ISceneManager* smgr = device -> getSceneManager();

    // Create a nanogui screen and pass the glfw pointer to initialize
    screen = new Screen();
    screen -> initialize(window, true);

    glfwSetCursorPosCallback(window,
            [](GLFWwindow *, double x, double y) {
            screen -> cursorPosCallbackEvent(x, y);
        }
    );

    glfwSetMouseButtonCallback(window,
        [](GLFWwindow *, i32 button, i32 action, i32 modifiers) {
            screen -> mouseButtonCallbackEvent(button, action, modifiers);
        }
    );

    glfwSetKeyCallback(window,
        [](GLFWwindow *, i32 key, i32 scancode, i32 action, i32 mods) {
            screen -> keyCallbackEvent(key, scancode, action, mods);
        }
    );

    glfwSetCharCallback(window,
        [](GLFWwindow *, unsigned i32 codepoint) {
            screen -> charCallbackEvent(codepoint);
        }
    );

    glfwSetDropCallback(window,
        [](GLFWwindow *, i32 count, const char **filenames) {
            screen -> dropCallbackEvent(count, filenames);
        }
    );

    glfwSetScrollCallback(window,
        [](GLFWwindow *, double x, double y) {
            screen -> scrollCallbackEvent(x, y);
       }
    );

    glfwSetFramebufferSizeCallback(window,
        [](GLFWwindow *, i32 width, i32 height) {
            screen -> resizeCallbackEvent(width, height);
        }
    );

    smgr -> addCameraSceneNode(0, core::vector3df(0,30,-40), core::vector3df(0,5,0));

    scene::IMeshSceneNode *cube;
    cube = smgr -> addCubeSceneNode(10);
    cube -> setMaterialFlag(video::EMF_LIGHTING, false);
    cube -> setPosition(core::vector3df(0, 0, 0));

    // Create nanogui gui
    screen -> add<Button>("Hola");

    cube = smgr -> addCubeSceneNode(10);
    cube -> setMaterialFlag(video::EMF_LIGHTING, false);
    cube -> setPosition(core::vector3df(10, 10, 10));
   
    screen -> setVisible(true);
    screen -> performLayout();

    cube = smgr -> addCubeSceneNode(10);
    cube -> setMaterialFlag(video::EMF_LIGHTING, false);
    cube -> setPosition(core::vector3df(20, 20, 20));

    // Game loop
    while (!glfwWindowShouldClose(window)) {
        // Check if any events have been activated (key pressed, mouse moved etc.) and call corresponding response functions
        glfwPollEvents();

        driver -> beginScene(true, true, video::SColor(255,100,101,140));

        // Draw nanogui
        smgr -> drawAll();
        screen -> drawWidgets();

        driver -> endScene();
    }

    // Terminate GLFW, clearing any resources allocated by GLFW.
    glfwTerminate();

    return 0;
}